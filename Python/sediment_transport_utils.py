{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ae9a6f63-ec74-48ad-b8a3-95150c006e50",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import scipy.io\n",
    "\n",
    "def load_data(filepath):\n",
    "    return scipy.io.loadmat(filepath)\n",
    "\n",
    "def extract_data(data, coastline_data):\n",
    "    tm_a = data['tm_a']\n",
    "    hs_a = data['hs_a']\n",
    "    dm_a = data['dm_a']\n",
    "    tm_s = data['tm_s']\n",
    "    hs_s = data['hs_s']\n",
    "    dm_s = data['dm_s']\n",
    "    tm_w = data['tm_w']\n",
    "    hs_w = data['hs_w']\n",
    "    dm_w = data['dm_w']\n",
    "    lon_f = data['lon_f'].flatten()\n",
    "    lat_f = data['lat_f'].flatten()\n",
    "    coastlineDirection = coastline_data['True_coastline_direction'].flatten()\n",
    "    return tm_a, hs_a, dm_a, tm_s, hs_s, dm_s, tm_w, hs_w, dm_w, lon_f, lat_f, coastlineDirection\n",
    "\n",
    "def calculate_normal_to_coastline(coastlineDirection):\n",
    "    normalToCoastline = np.zeros(len(coastlineDirection))\n",
    "    for i in range(len(coastlineDirection)):\n",
    "        if i <= 3 or (i >= 5 and i <= 8) or (i >= 9 and i <= 12) or (i >= 18 and i <= 23) or (i >= 35 and i <= 38):\n",
    "            normalToCoastline[i] = coastlineDirection[i] - 90\n",
    "        elif i == 4 or i == 24 or i > 38:\n",
    "            normalToCoastline[i] = (90 - coastlineDirection[i]) + 90\n",
    "        elif i >= 13 and i <= 17:\n",
    "            normalToCoastline[i] = (90 - coastlineDirection[i]) + 90\n",
    "    return normalToCoastline\n",
    "\n",
    "def adjust_wave_direction(normalToCoastline, dm):\n",
    "    adjustedDirection = []\n",
    "    for i in range(dm.shape[1]):\n",
    "        waveDirection = dm[:, i]\n",
    "        tempDir = np.zeros(len(waveDirection))\n",
    "        for j in range(len(waveDirection)):\n",
    "            if normalToCoastline[j] < 0:\n",
    "                tempDir[j] = abs(normalToCoastline[j]) - waveDirection[j]\n",
    "            else:\n",
    "                tempDir[j] = waveDirection[j] - normalToCoastline[j]\n",
    "        adjustedDirection.append(tempDir)\n",
    "    return np.array(adjustedDirection).T\n",
    "\n",
    "def calculate_wave_directions(normalToCoastline, dm_a, dm_s, dm_w):\n",
    "    waveDirRelToNorth_a = adjust_wave_direction(normalToCoastline, dm_a)\n",
    "    waveDirRelToNorth_s = adjust_wave_direction(normalToCoastline, dm_s)\n",
    "    waveDirRelToNorth_w = adjust_wave_direction(normalToCoastline, dm_w)\n",
    "    return waveDirRelToNorth_a, waveDirRelToNorth_s, waveDirRelToNorth_w\n",
    "\n",
    "def adapted_Larson2010(tm, hs, direction):\n",
    "    # Placeholder for the actual function implementation\n",
    "    return 0, 0, 0, 0, 0, 0\n",
    "\n",
    "def calculate_sediment_transport(tm, hs, adjustedDirection, lon_f):\n",
    "    numLocations = len(lon_f)\n",
    "    Thetab_f, Hb_f, hb_f, R_f, S_f, V_f = [], [], [], [], [], []\n",
    "    \n",
    "    for j in range(tm.shape[1]):\n",
    "        tm_f = tm[:, j]\n",
    "        hs_f = hs[:, j]\n",
    "        dir_f = adjustedDirection[:, j]\n",
    "        \n",
    "        Thetab, Hb, hb, R, S, V = np.zeros(numLocations), np.zeros(numLocations), np.zeros(numLocations), np.zeros(numLocations), np.zeros(numLocations), np.zeros(numLocations)\n",
    "        \n",
    "        for i in range(numLocations):\n",
    "            Thetab[i], Hb[i], hb[i], R[i], S[i], V[i] = adapted_Larson2010(tm_f[i], hs_f[i], dir_f[i])\n",
    "        \n",
    "        Thetab_f.append(Thetab)\n",
    "        Hb_f.append(Hb)\n",
    "        hb_f.append(hb)\n",
    "        R_f.append(R)\n",
    "        S_f.append(S)\n",
    "        V_f.append(V)\n",
    "    \n",
    "    return np.array(Thetab_f), np.array(Hb_f), np.array(hb_f), np.array(R_f), np.array(S_f), np.array(V_f)\n",
    "\n",
    "def calculate_omega(Hb_a, V_a, Hb_s, V_s, Hb_w, V_w):\n",
    "    OMEGA_a = calculate_omega_for_season(Hb_a, V_a)\n",
    "    OMEGA_s = calculate_omega_for_season(Hb_s, V_s)\n",
    "    OMEGA_w = calculate_omega_for_season(Hb_w, V_w)\n",
    "    return OMEGA_a, OMEGA_s, OMEGA_w\n",
    "\n",
    "def calculate_omega_for_season(Hb, V):\n",
    "    OMEGA = []\n",
    "    for j in range(Hb.shape[0]):\n",
    "        omega = Hb[j, :]**2 * V[j, :]\n",
    "        OMEGA.append(omega)\n",
    "    return np.array(OMEGA)\n",
    "\n",
    "def calculate_transport(OMEGA_a, OMEGA_s, OMEGA_w):\n",
    "    TRANSPORT_a = calculate_transport_for_season(OMEGA_a)\n",
    "    TRANSPORT_s = calculate_transport_for_season(OMEGA_s)\n",
    "    TRANSPORT_w = calculate_transport_for_season(OMEGA_w)\n",
    "    return TRANSPORT_a, TRANSPORT_s, TRANSPORT_w\n",
    "\n",
    "def calculate_transport_for_season(OMEGA):\n",
    "    TRANSPORT = []\n",
    "    for j in range(OMEGA.shape[0]):\n",
    "        omega = OMEGA[j, :]\n",
    "        transport = np.array([calculate_transport_value(o) for o in omega])\n",
    "        TRANSPORT.append(transport)\n",
    "    return np.array(TRANSPORT)\n",
    "\n",
    "def calculate_transport_value(omega):\n",
    "    if omega < 0.15:\n",
    "        return 0.023 * omega  # Calm periods\n",
    "    else:\n",
    "        return 0.00225 + 0.008 * omega  # Storm periods\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
